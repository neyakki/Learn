# Алгоритм

**Алгоритм** - процедура, которая принимает любой из возможных входных экземпляров и преобразует его в соответствии с требованиями, указанными в условии задачи. Алгоритм должен решать общую, корректно поставленную задачу. В качестве задачи выступают все множество экземпляров (входные данные), обрабатываемые алгоритмом, и результат после выполнения алгоритма.

Хороший алгоритм должен быть:

* *Корректным*;
* *Эффективным*;
* *Легкореализуемым*.

**Эвристический алгоритм** - алгоритм, не являющийся точным и оптимальным, но подходящий для решения задачи.

Алгоритмы, которые всегда выдают правильное решение, очень сильно отличаются от эвристических алгоритмов, которые обычно выдают достаточно хорошие, но не гарантированные результаты.

```ad-warning
Логичные алгоритмы могут оказаться правильными на первый взгляд, но на деле могут легко оказаться неправильными. Правильность алгоритма требует тщательного доказательства. Чтобы продемонстрировать правильность алгоритма, нужно подробное описание задачи. 
```

Постановка задачи состоит из двух частей:

- Набора допустимых входных экземпляров;
- Требования к выходу алгоритма.

```ad-info
Правильная постановка задачи является частью ее решения.
```

Экземпляр задачи, для которого алгоритм выдает не правильный результат, называется **контрпримером**. Он используется для доказательства неправильности алгоритма. Хороший контрпример должен обладать следующими свойствами:

- *Проверяемость* - способность доказать, что экземпляр задачи является контрпримером для алгоритма,  т.к. не был решен правильно;
- *Простотой* - контрпример не содержит ничего лишнего и ясно демонстрирует некорректность алгоритма.

```ad-info
Лучший способ доказать неправильность эвристического алгоритма - протестировать его на контрпримерах.
```

## Анализ алгоритмов

Для сравнения эффективности алгоритмов, не прибегая к их реализации, используется *модель вычисления RAM* и *асимптотический анализ сложности наихудшего случая*.

**Машина с произвольным доступом к памяти (RAM)** называется гипотетический компьютер, который помогает в разработке машинно-независимого алгоритма. По этой модели компьютер работает следующим образ:

- Простые операции выполняются за один временной шаг;
- Циклы и подпрограммы выполняются за $n$ временной шаг, т.е. зависят от количества операций;
- Обращение к памяти занимает один временной шаг.

Хотя по сравнению с настоящими компьютерами, RAM-машины неверны, но они представляют хорошую абстракцию. Таким образом, RAM-модель дает нам компромисс, отражая поведение компьютера и оставаясь очень простой, тем самым становясь полезной на практике.

### Наихудший, средний, наилучший случаи

Чтобы дать оценку алгоритму, нужно знать, как он работает со всеми экземплярами задачи. Таким образом, мы сможем определить наилучший, средний и наихудший случай сложности алгоритма.

- *Наихудший случай* - функция, определяемая максимальным количеством шагов для выполнения алгоритма;
- *Наилучший случай* - функция, определяемая минимальным количеством шагов для выполнения алгоритма;
- *Средний случай* - функция, определяемая средним количеством шагов.

На практике оценка наихудшего случая является очень важной оценкой.

### Асимптотические обозначения

Асимптотические функции, которые вычисляют временную сложность, представляют из себя числовую функцию от размера возможных экземпляров задачи. Однако работать с такими функциями трудно, потому что:

- Являются слишком волнистыми;
- Требуются слишком много информации для точного определения.

*Асимптотические обозначения* позволяют упростить анализ, потому что игнорируют детали, не влияющие на сравнение эффективности алгоритмов. Асимптотические обозначения позволяют игнорировать несущественные детали и концентрироваться на общей картине. Игнорируя постоянные множители, мы получаем превосходное общее представление о возможностях алгоритма решать  задачи определенного размера.

Формальные определения асимптотических обозначений:

- $f(n) = \mathsf{O}(g(n))$ - функция $f(n)$ ограничена сверху функцией $c * g(n)$. Т.е. существует такая константа $c$, для которой $f(n) \leqslant c * g(n)$ при достаточно большом $n$;

![img350-bigO](bigO.jpg)

- $f(n) = \Omega(g(n))$ - функция $f(n)$ ограничена снизу функцией $c * g(n)$. Т.е. существует такая константа $c$, для которой $f(n) \geqslant c * g(n)$ при достаточно большом $n$;

![img350-omega](omega.jpg)

- $f(n) = \Theta(g(n))$ - функция $f(n)$ ограничена сверху функцией $c_{1} * g_{1}(n)$, а снизу функцией $c_{2} * g_{2}(n)$. Т.е. существуют такие константы $c_{1}$ и $c_{2}$, для которых $c_{2} * g_{2}(n) \leqslant f(n) \leqslant c_{1} * g_{1}(n)$ при достаточно большом $n$. Как только $n$ становится большим, время выполнения алгоритма должно быть распределено между $c_{1} * g_{1}(n)$ и $c_{2} * g_{2}(n)$;

![img350-theta](theta.jpg)

Функции с быстрым темпом роста *доминируют* над менее возрастающими функциями.

Основные классы функций:

- *Функции-константы $f(n) = 1$*;
- *Логарифмические функции $f(n) = \log n$*;
- *Линейные функции $f(n) = n$*;
- *Суперлинейные функции $f(n) = n \lg n$*;
- *Квадратичные функции $f(n) = n^2$*;
- *Кубические функции $f(n) = n^3$*;
- *Показательные функции $f(n) = c^n$*;
- *Факториальные функции $f(n) = n!$*;

Отношение доминирования рассматриваются в следующем порядке:

$n! \gg 2^n \gg n^3 \gg n^2 \gg n \log n \gg n \gg \log n \gg 1$

![img500-complex](complex.png)

```ad-info
Приведенный выше список не является исчерпывающим, существует множество функций, время работы которых там не указано. Сложноть может быть, например, и такой $n^2 \lg n$
```

Сумма двух функций определяется доминантной функцией:

- $\mathsf{O}(f(n)) + \mathsf{O}(g(n)) = \mathsf{O}(\max(f(n),g(n)))$;
- $\Omega(f(n)) + \Omega(g(n)) = \Omega(\max(f(n),g(n)))$;
- $\Theta(f(n)) + \Theta(g(n)) = \Theta(\max(f(n),g(n)))$;

Например: $n^3 + n^2 + n + 1 = \mathsf{O}(n^3)$, т.к. $n^3$ является доминантной функцией.

Умножение функции на константу не может повлиять на ее асимптотическое поведение:

- $\mathsf{O}(с * f(n)) \rightarrow \mathsf{O}(f(n))$;
- $\Omega(с * f(n)) \rightarrow \Omega(f(n))$;
- $\Theta(с * f(n)) \rightarrow \Theta(f(n))$;

Но когда обе функции произведения возрастают, то они обе являются важными:

- $\mathsf{O}(f(n)) * \mathsf{O}(g(n)) \rightarrow \mathsf{O}(f(n) * g(n))$;
- $\Omega(f(n)) * \Omega(g(n)) \rightarrow \Omega(f(n) * g(n))$;
- $\Theta(f(n)) * \Theta(g(n)) \rightarrow \Theta(f(n) * g(n))$;

```ad-note
В книге [1] можно посмотреть примеры оценки алгоритмов
```

## Источники

1. Стивен Скиена. Алгоритмы . Руководство по разработке - 2-е изд. 1-2 глава;
2. Адитья Бхаргава. Грокаем алгоритмы;
3. https://ru.wikipedia.org/wiki/%D0%AD%D0%B2%D1%80%D0%B8%D1%81%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC;
4. https://www.khanacademy.org/computing/computer-science/algorithms/sorting-algorithms/a/sorting;
5. https://www.programiz.com/dsa/asymptotic-notations