---
tags:
  - data_structure
  - stack
date: 2024-10-24T18:52
---
# Stack
## Описание

***Стек*** - это структура данных и одновременно абстрактный тип данных, работающий по принципу **LIFO** (Last in, first out - Последний пришел, первый вышел).

**Свойства стека:**

- Добавлять и извлекать элементы можно только с вершины стека;
* Получить доступ можно только к верхнему элементу стека;

**Основные операции стека:**

* *push(element)* - добавление элемента на вершину стека;
- *pop()* - удаление и возврат элемента с вершины стека;
- *peek()* или *top()* - возвращает верхний элемент стека без его удаления;
- *isEmpty()* - проверка, пуст ли стек;
- *isFull()* - проверка, заполнен ли стек.

**Применения стека:**

- *Управление вызовом функции* - при вызове функции, она помещается в стек, а при завершении извлекается;
- *История браузера* - при переходе на страницу, она помещается в вершину стека;
- *Отмена изменений* - используется для сохранения состояния.

**Преимущества и недостатки стека:**

-  **Преимущества**:
	- Простота в использовании и реализации;
	- Эффективные операции добавления и удаления элементов с вершины стека (O(1), O(1)).

- **Недостатки**:
	- Ограниченный доступ к элементам — можно работать только с вершиной стека;
	- Если стек реализован на основе массива, его размер должен быть заранее известен (или массив нужно динамически расширять).

**Виды и реализация стека**:

- **Реализации стека** - описывают физическую организацию стека и его структуру данных.

	1. *Простая реализация стека на списке (массиве)* — реализация стека с использованием массива или списка.
	2. *Стек на основе связного списка (с использованием узлов)* — реализация стека с помощью связного списка.
	3. *Ограниченный стек (с методом `is_full`)* — стек с фиксированным размером, где можно проверять, достиг ли стек предельного объема.

- **Виды стека** - адаптации или расширения, применимые в различных алгоритмических задачах.

	1. *Min-Stack (Стек с поддержкой минимального элемента)* — стек, который позволяет в любой момент времени получить минимальный элемент за \(O(1)\).
	2. *Max-Stack (Стек с поддержкой максимального элемента)* — стек, который позволяет получать максимальный элемент за \(O(1)\).
	3. *Монотонный стек (Monotonic Stack)* — стек, элементы которого хранятся в строго возрастающем или убывающем порядке, используемый для оптимальных алгоритмов поиска.
	4. *Стек с размахом (Stack with Span)* — стек, который позволяет вычислять "размах" (длину подотрезка) для каждого элемента.
	5. *Стек для поиска следующего большего элемента (Next Greater Element Stack)* — стек для поиска ближайшего большего элемента справа в массиве.
	6. *Стек для поиска ближайшего меньшего элемента (Nearest Smaller Element Stack)* — стек для поиска ближайшего меньшего элемента слева или справа.
	7. *Постфиксный калькулятор на основе стека (Postfix Calculator)* — пример использования стека для вычисления выражений в обратной польской записи.
	8. *Стек с поддержкой произвольного количества максимумов (Custom Max-Stack)* — специализированная версия Max-Stack, которая может работать с несколькими максимальными элементами.

## Задачи

1. **Задача "Обратный порядок"**

   Напишите программу, которая принимает на вход строку и использует стек для вывода этой строки в обратном порядке. Например, для строки `"hello"` программа должна вывести `"olleh"`.

   **Подсказка**: поместите каждый символ строки в стек, затем извлеките их из стека и выведите в порядке извлечения.

2. **Задача "Проверка сбалансированных скобок"**

   Напишите функцию, которая проверяет, правильно ли расставлены круглые скобки в строке. Строка содержит только символы `(` и `)`. Строка считается правильной, если каждая открывающая скобка имеет соответствующую закрывающую.

   **Пример**:
   - Вход: `"((()))"`, результат: `True`
   - Вход: `"(()"`, результат: `False`

   **Подсказка**: Используйте стек для хранения открывающих скобок и удаляйте их, когда встречаете закрывающую.

3. **Задача "Минимум в стеке"**

   Реализуйте стек с дополнительной функцией `get_min()`, которая возвращает минимальный элемент в стеке за \(O(1)\) время. При этом должны поддерживаться стандартные операции стека: `push()`, `pop()`, и `peek()`.

   **Пример**:
   ```python
   stack.push(3)
   stack.push(5)
   print(stack.get_min())  # 3
   stack.push(2)
   stack.push(1)
   print(stack.get_min())  # 1
   stack.pop()
   print(stack.get_min())  # 2
   ```

   **Подсказка**: можно использовать дополнительный стек для отслеживания минимальных элементов.

4. **Задача "Преобразование инфиксной записи в постфиксную"**
   Напишите программу, которая принимает на вход арифметическое выражение в инфиксной записи (например, `"3 + 5 * ( 2 - 8 )"`) и преобразует его в постфиксную запись (обратную польскую нотацию). Используйте стек для управления приоритетом операций.

   **Пример**:
   - Вход: `"3 + 5 * 2"`, результат: `"3 5 2 * +"`

   **Подсказка**: Используйте алгоритм сортировочной станции для преобразования инфиксной записи в постфиксную.

5. **Задача "Оценка арифметического выражения в постфиксной нотации"**
   Напишите программу, которая принимает на вход арифметическое выражение в постфиксной записи (обратная польская нотация) и вычисляет его значение. Например, для выражения `"5 1 2 + 4 * + 3 -"` результат должен быть `14`.

   **Пример**:
   - Вход: `"2 3 + 5 *"`, результат: `25`
   - Вход: `"5 1 2 + 4 * + 3 -"`, результат: `14`

   **Подсказка**: Используйте стек для промежуточных вычислений. Когда встречаете операнд, кладите его в стек, а когда встречаете оператор — извлекайте два операнда для выполнения операции.

6. **Задача "Сортировка с помощью стека"**
   Реализуйте функцию, которая сортирует стек с использованием только самого стека и дополнительного вспомогательного стека. Никаких других структур данных (например, массивов или списков) использовать нельзя.

   **Пример**:
   - Входной стек: `[34, 3, 31, 98, 92, 23]`
   - Выходной стек (отсортированный): `[3, 23, 31, 34, 92, 98]`

   **Подсказка**: Для сортировки можно использовать алгоритм, напоминающий сортировку вставками, перемещая элементы между стеками.
