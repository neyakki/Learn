---
tags:
  - data_structure
  - "#queue"
date: 2024-10-24T18:52
---
# Queue

## Описание

***Очередь*** - структура данных, работающая по принципу FIFO (First in, first out - первый пришел, первый вышел). 

**Основные свойства очереди**:

- *Принцип работы FIFO* - Первый добавленный элемент будет первым удален;
- *Доступ к элементам* - Доступ возможен только к первому (головному) элементу очереди для его удаления и ко второму элементу для добавления.

**Основные операции с очередью**:

- *`enqueue(item)`* - Добавляет элемент в конец очереди (*сложность O(1)*);
- *`dequeue()`*  - Удаляет и возвращает первый элемент из очереди (*Сложность: O(1)*);
- *`peek()`* - Возвращает элемент из начала очереди без его удаления (*Сложность: O(1)*);
- *`isEmpty()`*  - Проверяет, пуста ли очередь (*Сложность: O(1)*);
- *`size()`* - Возвращает количество элементов в очереди (*Сложность: O(1)*).

**Виды очередей**:

- *Обычная очередь* - Стандартная очередь, где элементы добавляются в конец и удаляются из начала;
- *Двусторонняя очередь (Deque)* - Расширенная версия очереди, которая позволяет добавлять и удалять элементы с обоих концов;
- *Приоритетная очередь* - В этой очереди элементы извлекаются не в порядке их добавления, а в зависимости от приоритета. Элемент с наивысшим приоритетом извлекается первым, даже если был добавлен позже;
- *Циклическая очередь (Кольцевая очередь, Circular Queue)* - Здесь конец и начало очереди соединены, и, когда очередь заполняется, добавление новых элементов продолжается с начала, если там есть свободное место.

**Применение очередей**:

- *Системы управления процессами* - Очереди используются для планирования задач, например, в операционных системах, где процессы и задачи должны выполняться в порядке поступления;
- *Обработка данных в потоках* - Очереди часто применяются в многопоточном программировании для синхронизации потоков, где одни потоки могут добавлять задачи в очередь, а другие — извлекать их;
- *Очереди сообщений* - В системах передачи сообщений, таких как `Kafka` или `RabbitMQ`, используется концепция очередей для асинхронной передачи данных между процессами.

**Преимущества и недостатки очереди**:

- **Преимущества**:
	
	- *Простота использования* -Очереди обладают простой логикой, которая легко реализуется и используется;
	- *Эффективное управление ресурсами* - FIFO хорошо подходит для задач, где важен порядок обработки.
	- *Широкое применение* - Используются во множестве алгоритмов и систем, где требуется обработка элементов в порядке их поступления.

- **Недостатки**:

	- *Ограниченный доступ* - В отличие от массивов или списков, у очереди есть доступ только к первому и последнему элементам, что не всегда удобно.
	- *Операции с произвольным доступом* - Если нужно часто работать с элементами в середине, очередь неэффективна, так как для этого придется удалять элементы последовательно.

## Задачи

**Задача 1. Реализация простой очереди на основе списка**

Реализуйте класс очереди, используя Python `list`, поддерживающий следующие методы: `enqueue`, `dequeue`, `peek`, `is_empty`, `size`.

**Требования**:

- Очередь должна добавлять элементы в конец и удалять элементы из начала.
- Реализовать все методы с соответствующими проверками на пустоту.

**Пример**:

```python
q = Queue()
q.enqueue(1)
q.enqueue(2)
print(q.dequeue())  # 1
print(q.peek())     # 2
print(q.is_empty()) # False
```

**Задача 2. Проверка симметричности скобок**

Напишите программу, которая проверяет симметричность круглых скобок в строке с помощью очереди. Строка состоит только из символов `(` и `)`.

**Пример**:

- Ввод: `"(()())"`
- Вывод: `True`
- Ввод: `")(()"`
- Вывод: `False`

**Подсказка**: Используйте очередь для поочередной обработки символов строки.

**Задача 3. Реализация кольцевой очереди (Circular Queue)**

Реализуйте кольцевую очередь фиксированного размера. Очередь должна поддерживать операции добавления и удаления элементов. Если очередь полна, добавление новых элементов должно перезаписывать самые старые элементы.

**Требования**:

- Реализовать методы `enqueue`, `dequeue`, `is_empty`, `is_full`, `peek`, `size`.
- Очередь фиксированного размера с циклическим перезаполнением.

**Пример**:

```python
cq = CircularQueue(3)
cq.enqueue(1)
cq.enqueue(2)
cq.enqueue(3)
cq.enqueue(4)  # Перезапишет элемент 1
print(cq.dequeue())  # 2
print(cq.peek())     # 3
```

**Задача 4. Операции на двух очередях**

Реализуйте структуру данных, которая поддерживает две очереди внутри одного массива. При этом необходимо, чтобы обе очереди эффективно использовали общий массив, не превышая его границ.

**Требования**:

- Очереди не должны пересекаться в массиве.
- Реализуйте методы `enqueue(queue_id, item)`, `dequeue(queue_id)`, `peek(queue_id)`, где `queue_id` — это идентификатор первой или второй очереди.

**Пример**:

```python
dual_queue = DualQueue(5)
dual_queue.enqueue(1, 'a')  # В первую очередь
dual_queue.enqueue(2, 'b')  # Во вторую очередь
print(dual_queue.dequeue(1))  # 'a'
```

**Задача 5. Реализация приоритетной очереди**

Реализуйте приоритетную очередь с поддержкой операций добавления элемента с приоритетом и извлечения элемента с наивысшим приоритетом. Элементы с одинаковым приоритетом извлекаются в порядке добавления (FIFO для одинаковых приоритетов).

**Требования**:

- Реализовать методы `enqueue(item, priority)` и `dequeue()`.
- Очередь должна возвращать элемент с наивысшим приоритетом.

**Пример**:

```python
pq = PriorityQueue()
pq.enqueue('task1', 1)
pq.enqueue('task2', 3)
pq.enqueue('task3', 2)
print(pq.dequeue())  # task2 (приоритет 3)
print(pq.dequeue())  # task3 (приоритет 2)
```

**Задача 6. Модель многозадачности с очередями**

Напишите симуляцию планировщика задач для процессора, который обслуживает несколько процессов с помощью очереди. Каждый процесс представлен в виде пары `(название процесса, время выполнения)`. Процессор обслуживает каждый процесс поочередно в течение определенного кванта времени, а если процесс не завершился за этот квант, он отправляется обратно в конец очереди.

**Требования**:

- Реализовать модель очереди для процессов с квантованием времени.
- Вводом являются список процессов и квант времени.

**Пример**:

- Ввод: `[(Process1, 4), (Process2, 3), (Process3, 5)]`, квант времени: 2.
- Вывод: 
	- Процесс 1 обслужен частично, оставшееся время: 2.
	- Процесс 2 выполнен полностью.
	- Процесс 3 обслужен частично, оставшееся время: 3.
	- И т.д.
