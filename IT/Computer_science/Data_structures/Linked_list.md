---
tags:
  - "#data_structure"
  - "#linked_list"
date: 2024-10-24T18:51
---
# Linked List

## Описание

**_Связанный список_** - структура данных, которая состоит из связанных узлов, каждый из которых содержит данные и указатель на следующий узел.

**Основные компоненты связанного списка**:

- _Узел (Node)_ - содержит данные (например, число или объект) и указатель на следующий узел в списке;
- _Ссылка (или указатель)_: Это часть узла, которая указывает на следующий узел в списке.

**Виды связанных списков**:

- _Односвязный список (Singly Linked List)_ - Каждый узел содержит данные и ссылку только на следующий узел;
- _Двусвязный список (Doubly Linked List)_ - Каждый узел содержит данные, ссылку на следующий узел и ссылку на предыдущий узел, что позволяет двигаться как вперед, так и назад по списку;
- _Кольцевой список (Circular Linked List)_ - Особый тип связанного списка, где последний узел ссылается на первый, образуя замкнутую структуру.

**Методы связанного списка**:

- _Добавление элемента_:
  - `append(data)` — добавляет элемент в конец списка;
  - `prepend(data)` — добавляет элемент в начало списка;
  - `insert(index, data)` — вставляет элемент на заданную позицию.
- _Удаление элемента_:
  - `remove(data)` — удаляет первый элемент с указанным значением;
  - `pop()` — удаляет и возвращает последний элемент;
  - `remove_at(index)` — удаляет элемент по индексу.
- _Доступ к элементам_:
  - `get(index)` — возвращает элемент по указанному индексу;
  - `find(data)` — находит и возвращает индекс элемента с заданным значением;
  - `is_empty()` — проверяет, пуст ли список;
  - `size()` — возвращает количество элементов в списке.
- _Обход списка_:
  - `traverse()` — проходит по всем элементам списка (например, для вывода или обработки каждого элемента).
- _Очистка списка_:
  - `clear()` — удаляет все элементы списка.
- _Другие методы_:
  - `reverse()` — разворачивает список (для двусвязного списка);
  - `contains(data)` — проверяет, содержится ли элемент в списке.

**Преимущества и недостатки**:

- **Преимущества**:

  - _Динамическое распределение памяти_ - Размер списка может изменяться во время выполнения программы;
  - _Эффективные операции вставки и удаления_ - Вставка и удаление элементов в начале списка или в произвольной позиции выполняются эффективно, так как не нужно сдвигать элементы, как это делается в массиве;
  - _Гибкость в работе с памятью_ - Связанный список использует ровно столько памяти, сколько нужно для хранения текущего числа элементов;
  - _Легкость реализации других структур данных_ - Связанные списки являются основой для более сложных структур данных, таких как стеки, очереди, графы и деревья.

- **Недостатки**:
  - _Медленный доступ к элементам_ - Для получения элемента по индексу необходимо последовательно пройти все предыдущие узлы, начиная с головы списка;
  - _Увеличение расхода памяти_ - Каждый узел в связанном списке содержит дополнительную информацию — указатель на следующий (и, возможно, предыдущий) узел;
  - _Сложность реализации_ - Управление связями между узлами сложнее, чем с массивами;
  - _Неэффективность работы с кэш-памятью_ - Массивы располагаются в памяти последовательно, что делает их более кэш-эффективными по сравнению со связанными списками, элементы которых могут находиться в разных местах памяти.

## Задачи

**Задача 1. "Реализация односвязного списка"**

Реализуйте односвязный список с базовыми операциями:

- `append(data)` — добавление элемента в конец списка.
- `print_list()` — вывод всех элементов списка.

**Пример**:

```python
lst = LinkedList()
lst.append(1)
lst.append(2)
lst.append(3)
lst.print_list()  # 1 -> 2 -> 3
```

**Задача 2. "Удаление элемента с конца"**

Реализуйте метод `remove_last()` для односвязного списка, который удаляет последний элемент списка.

**Пример**:

```python
lst = LinkedList()
lst.append(10)
lst.append(20)
lst.append(30)
lst.remove_last()
lst.print_list()  # 10 -> 20
```

**Задача 3.  "Найти средний элемент в односвязном списке"**

Реализуйте функцию `find_middle()`, которая возвращает значение среднего элемента в односвязном списке. Постарайтесь сделать это за один проход по списку.

**Пример**:

```python
lst = LinkedList()
lst.append(10)
lst.append(20)
lst.append(30)
lst.append(40)
lst.append(50)
print(lst.find_middle())  # 30
```

**Подсказка**: используйте два указателя, один движется в два раза быстрее другого.

**Задача 4.  "Разворот связного списка"**

Реализуйте функцию `reverse()`, которая разворачивает односвязный список.

**Пример**:

```python
lst = LinkedList()
lst.append(1)
lst.append(2)
lst.append(3)
lst.reverse()
lst.print_list()  # 3 -> 2 -> 1
```

**Задача 5.  "Удаление всех дубликатов"**

Напишите функцию `remove_duplicates()`, которая удаляет все дубликаты из односвязного списка.

**Подсказка**: для удаления дубликатов можно использовать множество (set) для отслеживания уже встреченных элементов.

**Пример**:

```python
lst = LinkedList()
lst.append(10)
lst.append(20)
lst.append(10)
lst.append(30)
lst.remove_duplicates()
lst.print_list()  # 10 -> 20 -> 30
```

**Задача 6.  "Сложение чисел, представленных связанными списками"**

Даны два числа, представленные как связанные списки, где каждый узел содержит одну цифру. Цифры расположены в обратном порядке, то есть младший разряд стоит первым. Напишите функцию `add_lists()`, которая складывает два числа и возвращает результат в виде связного списка.

**Подсказка**: нужно аккуратно обрабатывать переносы разрядов при сложении.

**Пример**:

```python
# 342 + 465 = 807
lst1 = LinkedList()
lst1.append(2)
lst1.append(4)
lst1.append(3)

lst2 = LinkedList()
lst2.append(5)
lst2.append(6)
lst2.append(4)

result = add_lists(lst1, lst2)
result.print_list()  # 7 -> 0 -> 8
```

